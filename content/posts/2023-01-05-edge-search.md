---
title: Server-side fulltext search with 11ty and edge functions
tags: code
draft: true
---
[[toc]]

Fulltext search for a website can be implemented on the server or on the client. Each approach has pro´s and con´s:

## Client-side search
- Searching on the client can be done with any static website because you don´t need a server processing logic.
- You need to download the fulltext search index bevor you can start searching, therefore the first attempt to searching might take some time.
- If you do not want to download the index for each request, you have to implement a caching mechanism with a service worker.
- Depending on how the caching is implemented, your index might not contain the data from most recent builds.
- Once you have an index cached in the browser, and you access it throught a service worker, your search becomes offline capable.

## Server-side search
- Searching on the server requires the server processing search logic. The usual static website doesn´t have that, but Netlify allows you to do it with Netlify edge functions in a Deno environment (which would be the fastest) or with Netlify serverless functions in a Node environment.
- No need to download a fulltext search index to the client.
- No need to implement caching on the client.
- Every search operates on the most recent data from the most recent build.
- The search is not offline capable.

## Edge functions

My blog had a client-side search based on [Lunr](https://lunrjs.com) for years, but the recent availability of Netlify edge functions was reason enough trying to implement a server-side solution. I ended up doing it with [MiniSearch](https://github.com/lucaong/minisearch) and I describe here how I did it.

Netlify edge functions come with the big advantage of being executed in a datacenter closest to the requesting user, which reduces latency. Because Netlify edge functions are JavaScript executed in a Deno environment, the cold start time is faster than for serverless functions running in a Node environment, which again makes edge functions faster.

Netlify edge functions have an execution time limit of 50 ms, a code size limit of 20 MB after compression, and the memory consumption for a set of deployed edge functions must not exceed 512 MB.^[[<cite>Edge Function Limits</cite>](https://docs.netlify.com/edge-functions/limits/), Netlify] All of those limitations shouldn´t be a problem for implementing a server-side fulltext search. 

## The search index

Before working on the search function, the fulltext search index has to be created. This will be done each time the static site is built. In my case, with 11ty, I have a template file named `search-index.html` which I store under the input folder 11ty is using. The file looks like this:

```html
---
permalink: _edge/search-index.json
permalinkBypassOutputDir: true
eleventyExcludeFromCollections: true
layout: none
---
{ { collections.liveContent | searchIndex }}
```

A quick explanation of what´s going on here:

`permalink: _edge/search-index.json`
: The index is named `search-index.json` and will be stored in the same directory where the edge search function will reside. This allows the search function to import the index.

`permalinkBypassOutputDir: true`
: This setting ensures the `search-index.json` does not get stored in the output directory of the build, which is often `_site`.

`eleventyExcludeFromCollections: true`
: The should not be part of any collection.

`layout: none`
: The search index should not be generated by using the default layout template, which create HTML. Because I do not have a template named `none`, no layout template is used for generating the index.

`{ { collections.liveContent | searchIndex }}`
: The `liveContent` collections holds all content that is not a draft and will be visualized for the blog. I apply an 11ty filter named `searchIndex` which transforms the collection into a MiniSearch index in JSON format. The `searchIndex` filter resides in a file named `_eleventy/filters.js` and does the following:

```js
//_eleventy/filters.js

const MiniSearch = require('minisearch');

module.exports = {
    //...
    searchIndex: function (collection) {
        const INDEX_FIELDS = [
            'id', //the url of the page
            'title',
            'date',
            'abstract',
            'content']; //index the content

        const STORE_FIELDS = [
            'id', //the url of the page
            'title',
            'date',
            'abstract',
            'excerpt']; //do not store the content but the excerpt

        let miniSearch = new MiniSearch({ fields: INDEX_FIELDS, storeFields: STORE_FIELDS });
        for (let item of collection) {
            let mappedItem = mapItem(item);
            if (mappedItem.id && !miniSearch.has(mappedItem.id))    {
                miniSearch.add(mappedItem);
            }
        }

        let searchIndex = miniSearch.toJSON();
        //store the configured fields within the search index
        //to access it later when importing the index
        searchIndex.INDEX_FIELDS = INDEX_FIELDS;
        return JSON.stringify(searchIndex);
      }
      //...
}
```

To use MiniSearch in the 11ty filter, you have install it into your project

```shell
npm install --save-dev minisearch
```

Also, you see there is a `mapItem` function called by the `searchIndex` function. `mapItem` is a helper which again refers to `removeHtml` and `excerptFromText`. It maps the content that is relevant for the search index from the 11ty page data object to an object that can be consumed more easily for the search index processing. You can have all of the functions in a single file, in my case the file is named `_eleventy/filters.js`.

```js
//_eleventy/filters.js

const cheerio = require('cheerio');
const striptags = require('striptags');

module.exports = {
    // ...
    removeHtml: function (text) {	
        if (text) {
            const $ = cheerio.load(text);
            //remove anchors
            $('a.anchor').each(function () {
                $(this).remove();
            });
            return striptags($('body').html());
        }
    },
    excerptFromText: function (text) {
        let excerpt = this.removeHtml(text);
        if (excerpt) {
            let words = excerpt.split(' ');
            excerpt = words.slice(0, 25).join(' ');
            if (words.length > 25) {
                excerpt += ' …'
            }
        }
        return excerpt;
    },
    mapItem: function (item) {
        return {
            id: item.url,
            title: item.data.title,
            date: item.date,
            abstract: item.data.abstract,
            content: this.removeHtml(item.templateContent),
            excerpt: this.excerptFromText(item.templateContent)
        } 
    }
    //...
}
```
	
You need to add the packages striptags and cheerio to your project for this to work. Do install v2 of striptags to able to use common JS imports.

```shell
npm install --save-dev striptags@2 cheerio
```

Do not forget to add the `searchIndex` filter to your `.eleventy.js` configuration file:

```js
const filters = require('./_eleventy/filters.js');

module.exports = function (eleventyConfig) {
    //...
    eleventyConfig.addFilter('searchIndex', filters.searchIndex);
    //...
}
```

This should generate a fulltext search index of your content with each build and store it under `_edge/search-index.json` relative to the root of your project folder.

## Edge function environment

My blog is built with [11ty](https://www.11ty.dev), but you can have edge functions without that. The [Netlify documentation](https://docs.netlify.com/edge-functions/get-started/) is really good at explaining step by step how to setup your local environment. In my case, it was:

1. Create the `.netlify.toml` file in the projects root folder
2. Specify inside of the `.netlify.toml` where the edge functions will be stored. If nothing is specified, it will be inside of `netlify/edge-functions`, relative to the projects root folder. I wanted to have the edge functions in the `_edge` folder, which meant I added the following entry in the `.netlify.toml`: \
	```
	[build]
	edge_functions = "_edge"
	```
3. Specify the URL path for the edge function, and the name of file that holds the function code. In my case:
	```
	[[edge_functions]]
	path = "/api/search"
	function = "search"
	```
4. Install Netlify CLI globally with `npm install netlify-cli -g`.

## The edge function

